# 网关Http服务器配置
[HttpServer]
debug = true
address = "0.0.0.0"
port = 8080
body-limit = "100K"
version-header = "X-Version"
tls-cret-file = ""
tls-key-file = ""
[HttpServer.BasicAuth]
username = "yongjia.chen"
# password = "yongjiaxxl"

# Endpoint元数据配置中心
[Registry]
# 使用哪种元数据配置中心：默认zookeeper，可选[active,zookeeper]
registry-id = "active"
# ZK服务配置中心地址，支持,分多个地址列表
address = "tx.devserver.net:2181"
root-path = "/flux-metadata"

# DubboExange配置参数
[DubboExchange]
cluster = "failover"
# 日志开关；如果开启则打印Dubbo调用细节
trace-enable = false
# Decoder关于读取响应体的字段Key。当响应体为JSON(Map)类型时，会尝试查找以下字段来作为Http层的响应数据。
decoder-key-code = "@net.bytepowered.flux.http-status"
decoder-key-header = "@net.bytepowered.flux.http-headers"
decoder-key-body = "@net.bytepowered.flux.http-body"

# JWT验证配置

## Dubbo协议
[JsonWebTokenVerification]
disable = false
type-id = "JwtVerificationFilter"
[JsonWebTokenVerification.InitConfig]
# Http请求中Token的Header键名。默认: Authorization。支持域：[query, form, path, header, attr]，默认header
jwt-lookup-token = "header:Authorization"
jwt-issuer-key = "iss"
jwt-subject-key = "sub"
upstream-protocol = "DUBBO"
upstream-uri = "foo.bar.JWTService"
upstream-method = "getPrivateJwtSecret"

# Http后端JWT验证配置
[HttpJsonWebTokenVerification]
disable = false
type-id = "JwtVerificationFilter"
[HttpJsonWebTokenVerification.InitConfig]
jwt-lookup-token = "Authorization"
jwt-issuer-key = "iss"
jwt-subject-key = "sub"
upstream-protocol = "HTTP"
upstream-uri = "http://foo.bar.com:8080/jwt"
upstream-method = "POST"


# 访问权限验证
[PermissionVerification]
disable = false
type-id = "PermissionVerificationFilter"
[PermissionVerification.InitConfig]
# 访问Subject在JWT数据中的Key
subject-jwt-key = "uid"
# Optional: 指定权限验收Dubbo接口。
# 当interface非空时生效，接口定义：verify(String uid, String method, String pattern)
upstream-proto = "HTTP"
upstream-host = "http://bytepowered.net"
upstream-uri = "/jwt/permission"
upstream-method = "POST"

# 日志配置
[Logger]
level = "debug"